<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Decision Helper - Unit Tests</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f7fafc;
        }
        
        .test-container {
            background: white;
            padding: 20px;
            margin: 10px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .test-passed {
            border-left: 4px solid #48bb78;
        }
        
        .test-failed {
            border-left: 4px solid #e53e3e;
        }
        
        .test-title {
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .test-passed .test-title {
            color: #38a169;
        }
        
        .test-failed .test-title {
            color: #c53030;
        }
        
        .test-details {
            font-size: 0.9rem;
            color: #4a5568;
            margin-top: 8px;
        }
        
        .summary {
            background: #667eea;
            color: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <h1>Decision Helper - Unit Tests</h1>
    <div id="test-summary" class="summary">Running tests...</div>
    <div id="test-results"></div>

    <!-- Mock DOM elements needed for tests -->
    <div style="display: none;">
        <input id="circle-1" value="60">
        <input id="circle-2" value="40">
        <input id="circle-3" value="70">
        <input id="circle-4" value="30">
        <input id="circle-5" value="45">
        <input id="circle-6" value="55">
        <input id="circle-7" value="35">
        <input id="circle-8" value="65">
        <span id="total-1-2">100</span>
        <span id="total-3-4">100</span>
        <span id="total-5-6">100</span>
        <span id="total-7-8">100</span>
    </div>

    <script>
        console.log('Test script is loading...');
        
        // Test framework
        class TestRunner {
            constructor() {
                this.tests = [];
                this.passed = 0;
                this.failed = 0;
            }

            test(name, testFunction) {
                this.tests.push({ name, testFunction });
            }

            run() {
                const resultsDiv = document.getElementById('test-results');
                const summaryDiv = document.getElementById('test-summary');
                
                this.tests.forEach(({ name, testFunction }) => {
                    try {
                        testFunction();
                        this.renderTest(resultsDiv, name, true);
                        this.passed++;
                    } catch (error) {
                        this.renderTest(resultsDiv, name, false, error.message);
                        this.failed++;
                    }
                });

                summaryDiv.innerHTML = `Tests: ${this.tests.length} | Passed: ${this.passed} | Failed: ${this.failed}`;
                summaryDiv.style.backgroundColor = this.failed === 0 ? '#48bb78' : '#e53e3e';
            }

            renderTest(container, name, passed, error = null) {
                const testDiv = document.createElement('div');
                testDiv.className = `test-container ${passed ? 'test-passed' : 'test-failed'}`;
                
                const title = document.createElement('div');
                title.className = 'test-title';
                title.textContent = `${passed ? '✓' : '✗'} ${name}`;
                testDiv.appendChild(title);

                if (error) {
                    const details = document.createElement('div');
                    details.className = 'test-details';
                    details.textContent = `Error: ${error}`;
                    testDiv.appendChild(details);
                }

                container.appendChild(testDiv);
            }
        }

        function assert(condition, message) {
            if (!condition) {
                throw new Error(message || 'Assertion failed');
            }
        }

        function assertEqual(actual, expected, message) {
            if (actual !== expected) {
                throw new Error(message || `Expected ${expected}, got ${actual}`);
            }
        }

        // Simplified versions of functions under test
        function updateTotalDisplay(totalDisplay, value1, value2) {
            const total = value1 + value2;
            totalDisplay.textContent = total;
            
            if (total !== 100) {
                totalDisplay.classList.add('invalid');
            } else {
                totalDisplay.classList.remove('invalid');
            }
            
            return total;
        }

        function handleBalancedInput(changedInput, otherInput) {
            const changedValue = parseInt(changedInput.value) || 0;
            let otherValue = 100 - changedValue;
            
            if (changedValue < 0) {
                changedInput.value = 0;
                otherInput.value = 100;
                return { changed: 0, other: 100 };
            } else if (changedValue > 100) {
                changedInput.value = 100;
                otherInput.value = 0;
                return { changed: 100, other: 0 };
            } else {
                otherInput.value = otherValue;
                return { changed: changedValue, other: otherValue };
            }
        }

        function calculateScores(circles) {
            const { circle1, circle2, circle3, circle4, circle5, circle6, circle7, circle8 } = circles;
            
            // Validate that all pairs total 100
            const totals = [
                circle1 + circle2,
                circle3 + circle4,
                circle5 + circle6,
                circle7 + circle8
            ];

            const allValid = totals.every(total => total === 100);
            if (!allValid) {
                throw new Error('All comparisons must total exactly 100 points');
            }

            // Calculate final scores using PDF methodology
            const circle9 = circle1 + circle5;  // Total advantages for A
            const circle10 = circle2 + circle7; // Total disadvantages for A
            const circle11 = circle3 + circle6; // Total advantages for B
            const circle12 = circle4 + circle8; // Total disadvantages for B

            const optionAScore = circle9 - circle10;
            const optionBScore = circle11 - circle12;

            return {
                optionAScore,
                optionBScore,
                circle9,
                circle10,
                circle11,
                circle12
            };
        }

        function classifyDecision(optionAScore, optionBScore) {
            // Check for "No Brainer" first (extreme cases)
            if ((optionAScore > 50 && optionBScore < -50) || (optionBScore > 50 && optionAScore < -50)) {
                return 'No Brainer';
            }
            
            // Check for "Fence Sitter" (close scores) before other categories
            if (Math.abs(optionAScore - optionBScore) <= 20) {
                return 'Fence Sitter';
            }
            
            // Check for "Can't Lose" and "Can't Win"
            if (optionAScore > 0 && optionBScore > 0) {
                return "Can't Lose";
            } else if (optionAScore < 0 && optionBScore < 0) {
                return "Can't Win";
            } else {
                return 'Clear Choice';
            }
        }

        // Run tests
        const runner = new TestRunner();

        // Test balanced input functionality
        runner.test('Balanced input - normal case', () => {
            const input1 = { value: '60' };
            const input2 = { value: '40' };
            const result = handleBalancedInput(input1, input2);
            assertEqual(result.changed, 60);
            assertEqual(result.other, 40);
            assertEqual(input2.value, 40);
        });

        runner.test('Balanced input - boundary case (0)', () => {
            const input1 = { value: '0' };
            const input2 = { value: '50' };
            const result = handleBalancedInput(input1, input2);
            assertEqual(result.changed, 0);
            assertEqual(result.other, 100);
            assertEqual(input2.value, 100);
        });

        runner.test('Balanced input - boundary case (100)', () => {
            const input1 = { value: '100' };
            const input2 = { value: '50' };
            const result = handleBalancedInput(input1, input2);
            assertEqual(result.changed, 100);
            assertEqual(result.other, 0);
            assertEqual(input2.value, 0);
        });

        runner.test('Balanced input - invalid negative', () => {
            const input1 = { value: '-10' };
            const input2 = { value: '50' };
            const result = handleBalancedInput(input1, input2);
            assertEqual(result.changed, 0);
            assertEqual(result.other, 100);
            assertEqual(input1.value, 0);
            assertEqual(input2.value, 100);
        });

        runner.test('Balanced input - invalid over 100', () => {
            const input1 = { value: '150' };
            const input2 = { value: '50' };
            const result = handleBalancedInput(input1, input2);
            assertEqual(result.changed, 100);
            assertEqual(result.other, 0);
            assertEqual(input1.value, 100);
            assertEqual(input2.value, 0);
        });

        // Test total display functionality
        runner.test('Total display - valid total (100)', () => {
            const totalDisplay = document.createElement('span');
            const total = updateTotalDisplay(totalDisplay, 60, 40);
            assertEqual(total, 100);
            assertEqual(totalDisplay.textContent, '100');
            assert(!totalDisplay.classList.contains('invalid'));
        });

        runner.test('Total display - invalid total (not 100)', () => {
            const totalDisplay = document.createElement('span');
            const total = updateTotalDisplay(totalDisplay, 60, 50);
            assertEqual(total, 110);
            assertEqual(totalDisplay.textContent, '110');
            assert(totalDisplay.classList.contains('invalid'));
        });

        // Test calculation functionality
        runner.test('Calculate scores - valid input', () => {
            const circles = {
                circle1: 60, circle2: 40,  // A internal: 60 adv, 40 dis
                circle3: 70, circle4: 30,  // B internal: 70 adv, 30 dis
                circle5: 45, circle6: 55,  // A vs B advantages: 45 vs 55
                circle7: 35, circle8: 65   // A vs B disadvantages: 35 vs 65
            };
            
            const result = calculateScores(circles);
            
            // Option A: (60 + 45) - (40 + 35) = 105 - 75 = 30
            assertEqual(result.optionAScore, 30);
            // Option B: (70 + 55) - (30 + 65) = 125 - 95 = 30
            assertEqual(result.optionBScore, 30);
            assertEqual(result.circle9, 105);  // A advantages total
            assertEqual(result.circle10, 75);  // A disadvantages total
            assertEqual(result.circle11, 125); // B advantages total
            assertEqual(result.circle12, 95);  // B disadvantages total
        });

        runner.test('Calculate scores - invalid totals', () => {
            const circles = {
                circle1: 60, circle2: 50,  // Invalid: totals 110
                circle3: 70, circle4: 30,
                circle5: 45, circle6: 55,
                circle7: 35, circle8: 65
            };
            
            let errorThrown = false;
            try {
                calculateScores(circles);
            } catch (error) {
                errorThrown = true;
                assert(error.message.includes('100 points'));
            }
            assert(errorThrown, 'Should throw error for invalid totals');
        });

        // Test decision classification
        runner.test('Decision classification - No Brainer (A positive, B negative)', () => {
            const classification = classifyDecision(80, -60);
            assertEqual(classification, 'No Brainer');
        });

        runner.test('Decision classification - No Brainer (B positive, A negative)', () => {
            const classification = classifyDecision(-60, 80);
            assertEqual(classification, 'No Brainer');
        });

        runner.test('Decision classification - Can\'t Lose (both positive)', () => {
            const classification = classifyDecision(50, 25);  // Changed: difference is 25, > 20 and both positive
            assertEqual(classification, "Can't Lose");
        });

        runner.test('Decision classification - Can\'t Win (both negative)', () => {
            const classification = classifyDecision(-50, -25);  // Changed: difference is 25, > 20 and both negative
            assertEqual(classification, "Can't Win");
        });

        runner.test('Decision classification - Fence Sitter (close scores)', () => {
            const classification = classifyDecision(15, 10);  // difference is 5, within 20
            assertEqual(classification, 'Fence Sitter');
        });

        runner.test('Decision classification - Clear Choice', () => {
            const classification = classifyDecision(30, -10);  // Changed: one positive, one negative, difference > 20
            assertEqual(classification, 'Clear Choice');
        });

        // Test score range validation
        runner.test('Score range - maximum possible', () => {
            const circles = {
                circle1: 100, circle2: 0,   // A: 100 adv, 0 dis
                circle3: 0, circle4: 100,   // B: 0 adv, 100 dis
                circle5: 100, circle6: 0,   // A vs B adv: 100 vs 0
                circle7: 0, circle8: 100    // A vs B dis: 0 vs 100
            };
            
            const result = calculateScores(circles);
            // A: (100 + 100) - (0 + 0) = 200
            // B: (0 + 0) - (100 + 100) = -200
            assertEqual(result.optionAScore, 200);
            assertEqual(result.optionBScore, -200);
        });

        runner.test('Score range - minimum possible', () => {
            const circles = {
                circle1: 0, circle2: 100,   // A: 0 adv, 100 dis
                circle3: 100, circle4: 0,   // B: 100 adv, 0 dis
                circle5: 0, circle6: 100,   // A vs B adv: 0 vs 100
                circle7: 100, circle8: 0    // A vs B dis: 100 vs 0
            };
            
            const result = calculateScores(circles);
            // A: (0 + 0) - (100 + 100) = -200
            // B: (100 + 100) - (0 + 0) = 200
            assertEqual(result.optionAScore, -200);
            assertEqual(result.optionBScore, 200);
        });

        // Refresh Button Tests
        runner.test('Universal start-over button - clear form data', () => {
            // Create mock inputs and textareas
            const mockInput = document.createElement('input');
            mockInput.value = 'test input value';
            const mockTextarea = document.createElement('textarea');
            mockTextarea.value = 'test textarea content';
            
            // Add them to DOM temporarily
            document.body.appendChild(mockInput);
            document.body.appendChild(mockTextarea);
            
            // Simulate the form clearing part of universalStartOver
            document.querySelectorAll('input, textarea').forEach(element => {
                element.value = '';
            });
            
            // Verify forms were cleared
            assertEqual(mockInput.value, '');
            assertEqual(mockTextarea.value, '');
            
            // Clean up
            document.body.removeChild(mockInput);
            document.body.removeChild(mockTextarea);
        });

        runner.test('Universal start-over button - reload methods available', () => {
            // Test that the reload methods exist and are functions
            assert(typeof window.location.reload === 'function', 'window.location.reload should be a function');
            assert(typeof window.location.replace === 'function', 'window.location.replace should be a function');
            assert(typeof window.location.href === 'string', 'window.location.href should be accessible');
            assert(typeof window.location.pathname === 'string', 'window.location.pathname should be accessible');
            assert(typeof window.location.search === 'string', 'window.location.search should be accessible');
        });

        runner.test('Universal start-over button - cascading reload logic', () => {
            // Test the logic structure without actually touching window.location methods
            // This tests the conceptual flow of our cascading approach
            
            // Test scenario 1: Simulate successful first method
            function mockReload(forceReload) {
                if (forceReload === true) {
                    return { success: true, method: 'reload' };
                }
                throw new Error('Invalid reload parameter');
            }
            
            let result = mockReload(true);
            assert(result.success === true, 'First method (reload) should succeed with proper parameter');
            assert(result.method === 'reload', 'Should identify reload method');
            
            // Test scenario 2: Simulate first method fails, second succeeds
            function mockReloadFails() {
                throw new Error('Reload failed');
            }
            
            function mockReplace(url) {
                if (typeof url === 'string' && url.length > 0) {
                    return { success: true, method: 'replace' };
                }
                throw new Error('Invalid URL');
            }
            
            try {
                mockReloadFails();
                assert(false, 'Should have thrown error');
            } catch (e) {
                result = mockReplace('http://example.com');
                assert(result.success === true, 'Second method (replace) should succeed');
                assert(result.method === 'replace', 'Should identify replace method');
            }
            
            // Test scenario 3: Fallback URL construction logic
            const mockLocation = {
                pathname: '/test-path',
                search: '?param=value'
            };
            
            const fallbackUrl = mockLocation.pathname + mockLocation.search;
            assert(typeof fallbackUrl === 'string', 'Fallback URL should be constructible');
            assert(fallbackUrl === '/test-path?param=value', 'Should construct correct fallback URL');
            assert(fallbackUrl.length > 1, 'Fallback URL should have substantial content');
            
            // Test scenario 4: Error handling flow
            let errorCount = 0;
            
            function cascadingLogic() {
                try {
                    mockReloadFails();
                } catch (e1) {
                    errorCount++;
                    try {
                        throw new Error('Replace also failed');
                    } catch (e2) {
                        errorCount++;
                        // Would fall back to href assignment
                        return 'fallback-executed';
                    }
                }
            }
            
            const finalResult = cascadingLogic();
            assert(errorCount === 2, 'Should catch both method failures');
            assert(finalResult === 'fallback-executed', 'Should execute fallback when both methods fail');
        });

        // Hash Navigation Tests
        runner.test('Hash navigation - selection mock data', () => {
            // Test the mock data structure for selection navigation
            const mockData = {
                choices: ['Take the new job', 'Stay at current company', 'Start freelancing'],
                selectedOptionA: 'Take the new job',
                selectedOptionB: 'Stay at current company'
            };
            
            // Verify mock data structure is correct
            assert(mockData.choices.length >= 2, 'Should have at least 2 choices');
            assert(mockData.selectedOptionA, 'Should have selectedOptionA');
            assert(mockData.selectedOptionB, 'Should have selectedOptionB');
            assert(mockData.selectedOptionA !== mockData.selectedOptionB, 'Options should be different');
        });

        runner.test('Hash navigation - comparison mock data', () => {
            // Test the mock data structure for comparison navigation
            const mockData = {
                choices: ['Take the new job', 'Stay at current company', 'Start freelancing'],
                selectedOptionA: 'Take the new job',
                selectedOptionB: 'Stay at current company'
            };
            
            // Verify the comparison setup would work
            assert(mockData.selectedOptionA, 'Should have selected option A');
            assert(mockData.selectedOptionB, 'Should have selected option B');
            assert(mockData.choices.includes(mockData.selectedOptionA), 'Option A should be in choices');
            assert(mockData.choices.includes(mockData.selectedOptionB), 'Option B should be in choices');
        });

        runner.test('Hash navigation - scoring mock data', () => {
            // Test the mock data structure for scoring navigation
            const mockData = {
                selectedOptionA: 'Take the new job',
                selectedOptionB: 'Stay at current company',
                advantagesA: 'Higher salary\nNew challenges\nBetter work-life balance\nOpportunity for growth',
                disadvantagesA: 'Unknown work culture\nLonger commute\nNeed to learn new systems\nLeaving established relationships',
                advantagesB: 'Familiar environment\nEstablished relationships\nShort commute\nKnown expectations',
                disadvantagesB: 'Limited growth opportunities\nLower pay\nRepetitive work\nHigh stress levels'
            };
            
            // Verify scoring setup data is complete
            assert(mockData.advantagesA, 'Should have advantages for option A');
            assert(mockData.disadvantagesA, 'Should have disadvantages for option A');
            assert(mockData.advantagesB, 'Should have advantages for option B');
            assert(mockData.disadvantagesB, 'Should have disadvantages for option B');
            assert(mockData.advantagesA.length > 10, 'Should have substantial content for advantages A');
            assert(mockData.disadvantagesA.length > 10, 'Should have substantial content for disadvantages A');
        });

        runner.test('Hash navigation - results calculation', () => {
            // Test the slider values and calculation for results navigation
            const mockSliderValues = {
                'slider-1-2': 70,  // Option A internal: 70 adv, 30 dis
                'slider-3-4': 40,  // Option B internal: 40 adv, 60 dis
                'slider-5-6': 60,  // Advantages comparison: 60 A, 40 B
                'slider-7-8': 30   // Disadvantages comparison: 30 A, 70 B
            };
            
            // Convert slider values to circles for calculation test
            const circles = {
                circle1: mockSliderValues['slider-1-2'],           // 70
                circle2: 100 - mockSliderValues['slider-1-2'],    // 30
                circle3: mockSliderValues['slider-3-4'],           // 40
                circle4: 100 - mockSliderValues['slider-3-4'],    // 60
                circle5: mockSliderValues['slider-5-6'],           // 60
                circle6: 100 - mockSliderValues['slider-5-6'],    // 40
                circle7: mockSliderValues['slider-7-8'],           // 30
                circle8: 100 - mockSliderValues['slider-7-8']     // 70
            };
            
            // Test that calculation would work with these values
            const result = calculateScores(circles);
            
            // Verify results are reasonable
            assert(typeof result.optionAScore === 'number', 'Should calculate option A score');
            assert(typeof result.optionBScore === 'number', 'Should calculate option B score');
            assert(result.optionAScore >= -200 && result.optionAScore <= 200, 'Option A score should be in valid range');
            assert(result.optionBScore >= -200 && result.optionBScore <= 200, 'Option B score should be in valid range');
            
            // Test decision classification with these scores
            const decisionType = classifyDecision(result.optionAScore, result.optionBScore);
            assert(decisionType, 'Should classify decision type');
            const validTypes = ['No Brainer', "Can't Lose", "Can't Win", 'Fence Sitter', 'Clear Choice'];
            assert(validTypes.includes(decisionType), `Decision type '${decisionType}' should be valid`);
        });

        runner.test('Hash navigation - Mock data consistency', () => {
            // Test that all hash navigation functions would use consistent data
            const mockData = {
                choices: ['Take the new job', 'Stay at current company', 'Start freelancing'],
                selectedOptionA: 'Take the new job',
                selectedOptionB: 'Stay at current company'
            };
            
            // Verify data consistency across different hash modes
            assert(mockData.choices.includes(mockData.selectedOptionA), 'Selected A should be in choices list');
            assert(mockData.choices.includes(mockData.selectedOptionB), 'Selected B should be in choices list');
            assert(mockData.choices.length >= 2, 'Should have enough choices for selection');
            
            // Test option names are reasonable length
            assert(mockData.selectedOptionA.length > 5, 'Option A name should be descriptive');
            assert(mockData.selectedOptionB.length > 5, 'Option B name should be descriptive');
        });

        // Save/Resume functionality tests
        runner.test('Save data - structure validation', () => {
            // Mock localStorage for testing
            const mockStorage = {};
            const mockLocalStorage = {
                setItem: (key, value) => mockStorage[key] = value,
                getItem: (key) => mockStorage[key] || null,
                removeItem: (key) => delete mockStorage[key]
            };

            // Test data structure
            const testData = {
                choices: ['Option A', 'Option B', 'Option C'],
                selectedOptionA: 'Option A',
                selectedOptionB: 'Option B',
                currentSection: 'comparison',
                formData: {
                    choiceInputs: ['Option A', 'Option B', 'Option C'],
                    advantagesA: 'Some advantages',
                    disadvantagesA: 'Some disadvantages',
                    advantagesB: 'Other advantages',
                    disadvantagesB: 'Other disadvantages',
                    sliderValues: {
                        'slider-1-2': 60,
                        'slider-3-4': 70,
                        'slider-5-6': 45,
                        'slider-7-8': 55
                    }
                },
                timestamp: Date.now()
            };

            // Test saving
            mockLocalStorage.setItem('decisionHelperData', JSON.stringify(testData));
            const saved = mockLocalStorage.getItem('decisionHelperData');
            assert(saved !== null, 'Data should be saved');

            // Test retrieving and parsing
            const parsed = JSON.parse(saved);
            assert(parsed.choices.length === 3, 'Should preserve choices array');
            assert(parsed.selectedOptionA === 'Option A', 'Should preserve selected option A');
            assert(parsed.selectedOptionB === 'Option B', 'Should preserve selected option B');
            assert(parsed.currentSection === 'comparison', 'Should preserve current section');
            assert(typeof parsed.timestamp === 'number', 'Should have timestamp');
        });

        runner.test('Save data - form data preservation', () => {
            const testFormData = {
                choiceInputs: ['Job A', 'Job B'],
                advantagesA: 'Higher salary\nBetter benefits',
                disadvantagesA: 'Longer commute\nMore stress',
                advantagesB: 'Work from home\nFlexible hours',
                disadvantagesB: 'Lower pay\nLess stability',
                sliderValues: {
                    'slider-1-2': 65,
                    'slider-3-4': 40,
                    'slider-5-6': 75,
                    'slider-7-8': 30
                }
            };

            // Test all form data fields are present
            assert(Array.isArray(testFormData.choiceInputs), 'Choice inputs should be array');
            assert(typeof testFormData.advantagesA === 'string', 'Advantages A should be string');
            assert(typeof testFormData.disadvantagesA === 'string', 'Disadvantages A should be string');
            assert(typeof testFormData.advantagesB === 'string', 'Advantages B should be string');
            assert(typeof testFormData.disadvantagesB === 'string', 'Disadvantages B should be string');
            assert(typeof testFormData.sliderValues === 'object', 'Slider values should be object');

            // Test slider values are in valid range
            Object.values(testFormData.sliderValues).forEach((value, index) => {
                assert(typeof value === 'number', `Slider value ${index} should be number`);
                assert(value >= 0 && value <= 100, `Slider value ${index} should be 0-100`);
            });
        });

        runner.test('Save data - section validation', () => {
            const validSections = ['brainstorm', 'selection', 'comparison', 'scoring', 'results'];
            
            validSections.forEach(section => {
                const testData = {
                    currentSection: section,
                    choices: ['A', 'B'],
                    selectedOptionA: 'A',
                    selectedOptionB: 'B',
                    formData: {},
                    timestamp: Date.now()
                };

                // Each section should be a valid string
                assert(typeof testData.currentSection === 'string', `Section ${section} should be string`);
                assert(validSections.includes(testData.currentSection), `Section ${section} should be valid`);
                assert(testData.currentSection.length > 0, `Section ${section} should not be empty`);
            });
        });

        runner.test('Resume data - localStorage availability check', () => {
            // Test that localStorage-like functionality can be mocked
            const mockStorage = {};
            const localStorage = {
                setItem: (key, value) => mockStorage[key] = value,
                getItem: (key) => mockStorage[key] || null,
                removeItem: (key) => delete mockStorage[key]
            };

            // Test basic operations
            localStorage.setItem('test', 'value');
            assert(localStorage.getItem('test') === 'value', 'Should store and retrieve values');
            
            localStorage.removeItem('test');
            assert(localStorage.getItem('test') === null, 'Should remove values');

            // Test JSON operations
            const testObj = { test: 'data', number: 123 };
            localStorage.setItem('json-test', JSON.stringify(testObj));
            const retrieved = JSON.parse(localStorage.getItem('json-test'));
            assert(retrieved.test === 'data', 'Should handle JSON data');
            assert(retrieved.number === 123, 'Should preserve data types in JSON');
        });

        runner.test('Resume data - data validation', () => {
            // Test that loaded data is properly validated
            const validData = {
                choices: ['Option 1', 'Option 2'],
                selectedOptionA: 'Option 1',
                selectedOptionB: 'Option 2',
                currentSection: 'comparison',
                formData: {
                    choiceInputs: ['Option 1', 'Option 2'],
                    advantagesA: 'Pros for option 1',
                    disadvantagesA: 'Cons for option 1',
                    advantagesB: 'Pros for option 2',
                    disadvantagesB: 'Cons for option 2',
                    sliderValues: {
                        'slider-1-2': 50,
                        'slider-3-4': 60,
                        'slider-5-6': 40,
                        'slider-7-8': 70
                    }
                },
                timestamp: Date.now()
            };

            // Validate structure
            assert(Array.isArray(validData.choices), 'Choices should be array');
            assert(validData.choices.length >= 2, 'Should have at least 2 choices');
            assert(typeof validData.selectedOptionA === 'string', 'Selected A should be string');
            assert(typeof validData.selectedOptionB === 'string', 'Selected B should be string');
            assert(validData.selectedOptionA !== validData.selectedOptionB, 'Options should be different');

            // Validate form data exists
            assert(validData.formData, 'Should have form data');
            assert(typeof validData.formData === 'object', 'Form data should be object');
            assert(validData.formData.sliderValues, 'Should have slider values');

            // Validate timestamp
            assert(typeof validData.timestamp === 'number', 'Timestamp should be number');
            assert(validData.timestamp > 0, 'Timestamp should be positive');
        });

        runner.test('Clear saved data - localStorage cleanup', () => {
            // Test data clearing functionality
            const mockStorage = { 'decisionHelperData': 'some-data', 'other-data': 'should-remain' };
            const localStorage = {
                removeItem: (key) => delete mockStorage[key],
                getItem: (key) => mockStorage[key] || null
            };

            // Verify data exists initially
            assert(localStorage.getItem('decisionHelperData') === 'some-data', 'Test data should exist');
            assert(localStorage.getItem('other-data') === 'should-remain', 'Other data should exist');

            // Clear decision data
            localStorage.removeItem('decisionHelperData');

            // Verify only decision data was cleared
            assert(localStorage.getItem('decisionHelperData') === null, 'Decision data should be cleared');
            assert(localStorage.getItem('other-data') === 'should-remain', 'Other data should remain');
        });

        runner.test('Auto-save frequency - silent operation', () => {
            // Test that auto-save can be called frequently without issues
            let saveCount = 0;
            const mockSave = (showIndicator = false) => {
                saveCount++;
                return !showIndicator; // Return true if silent (no indicator)
            };

            // Simulate frequent saves (typing, slider changes)
            const silentSave1 = mockSave(false);
            const silentSave2 = mockSave(false);
            const silentSave3 = mockSave(false);

            // Simulate explicit save (section transition)
            const explicitSave = mockSave(true);

            assert(saveCount === 4, 'Should track all save operations');
            assert(silentSave1 === true, 'Silent saves should not show indicator');
            assert(silentSave2 === true, 'Silent saves should not show indicator');
            assert(silentSave3 === true, 'Silent saves should not show indicator');
            assert(explicitSave === false, 'Explicit saves should show indicator');
        });

        runner.test('Section navigation - restore to correct section', () => {
            // Test section navigation logic
            const sectionData = [
                { section: 'brainstorm', hasChoices: true, hasOptions: false },
                { section: 'selection', hasChoices: true, hasOptions: false },
                { section: 'comparison', hasChoices: true, hasOptions: true },
                { section: 'scoring', hasChoices: true, hasOptions: true },
                { section: 'results', hasChoices: true, hasOptions: true }
            ];

            sectionData.forEach(({ section, hasChoices, hasOptions }) => {
                const mockData = {
                    currentSection: section,
                    choices: hasChoices ? ['A', 'B', 'C'] : [],
                    selectedOptionA: hasOptions ? 'A' : '',
                    selectedOptionB: hasOptions ? 'B' : ''
                };

                // Test navigation requirements
                if (section === 'selection') {
                    assert(mockData.choices.length >= 3, 'Selection requires 3+ choices');
                }
                if (['comparison', 'scoring', 'results'].includes(section)) {
                    assert(mockData.selectedOptionA, `${section} requires selected option A`);
                    assert(mockData.selectedOptionB, `${section} requires selected option B`);
                    assert(mockData.selectedOptionA !== mockData.selectedOptionB, `${section} requires different options`);
                }
            });
        });

        // Navigation History Tests
        runner.test('Navigation history - initialization', () => {
            // Test navigation history initialization
            const mockNavigationHistory = [];
            let mockCurrentHistoryIndex = -1;

            // Mock initialization function behavior
            function mockInitializeNavigationHistory() {
                if (mockNavigationHistory.length === 0) {
                    const initialState = {
                        choices: [],
                        selectedOptionA: '',
                        selectedOptionB: '',
                        formData: { choiceInputs: [], advantagesA: '', disadvantagesA: '', advantagesB: '', disadvantagesB: '', sliderValues: {} }
                    };
                    mockNavigationHistory.push({
                        section: 'brainstorm',
                        state: initialState,
                        timestamp: Date.now()
                    });
                    mockCurrentHistoryIndex = 0;
                }
                return { history: mockNavigationHistory, index: mockCurrentHistoryIndex };
            }

            const result = mockInitializeNavigationHistory();
            
            assert(result.history.length === 1, 'Should create initial history entry');
            assert(result.index === 0, 'Should set current index to 0');
            assert(result.history[0].section === 'brainstorm', 'Initial entry should be brainstorm section');
            assert(typeof result.history[0].timestamp === 'number', 'Should have timestamp');
            
            // Test that second initialization doesn't create duplicate
            const result2 = mockInitializeNavigationHistory();
            assert(result2.history.length === 1, 'Should not create duplicate entries');
        });

        runner.test('Navigation history - adding entries', () => {
            // Test adding navigation entries
            const mockHistory = [{
                section: 'brainstorm',
                state: { choices: ['A', 'B'] },
                timestamp: Date.now() - 1000
            }];
            let mockIndex = 0;

            function mockAddToNavigationHistory(targetSection, currentState) {
                // If we're not at the end of history, remove everything after current position
                if (mockIndex < mockHistory.length - 1) {
                    mockHistory.splice(mockIndex + 1);
                }
                
                // Add new state to history
                mockHistory.push({
                    section: targetSection,
                    state: currentState,
                    timestamp: Date.now()
                });
                
                mockIndex = mockHistory.length - 1;
                return { history: mockHistory, index: mockIndex };
            }

            // Add comparison section
            const comparisonState = { 
                choices: ['A', 'B'], 
                selectedOptionA: 'A', 
                selectedOptionB: 'B' 
            };
            const result = mockAddToNavigationHistory('comparison', comparisonState);

            assert(result.history.length === 2, 'Should add new entry');
            assert(result.index === 1, 'Should update current index');
            assert(result.history[1].section === 'comparison', 'Should add comparison section');
            assert(result.history[1].state.selectedOptionA === 'A', 'Should preserve state');
        });

        runner.test('Navigation history - can go back/forward logic', () => {
            // Test navigation capability logic
            const testCases = [
                { historyLength: 1, currentIndex: 0, canBack: false, canForward: false, desc: 'single entry' },
                { historyLength: 2, currentIndex: 0, canBack: false, canForward: true, desc: 'at beginning of multiple entries' },
                { historyLength: 2, currentIndex: 1, canBack: true, canForward: false, desc: 'at end of multiple entries' },
                { historyLength: 3, currentIndex: 1, canBack: true, canForward: true, desc: 'in middle of multiple entries' },
                { historyLength: 0, currentIndex: -1, canBack: false, canForward: false, desc: 'empty history' }
            ];

            testCases.forEach(({ historyLength, currentIndex, canBack, canForward, desc }) => {
                function mockCanGoBack(index) {
                    return index > 0;
                }

                function mockCanGoForward(index, length) {
                    return index < length - 1;
                }

                const actualCanBack = mockCanGoBack(currentIndex);
                const actualCanForward = mockCanGoForward(currentIndex, historyLength);

                assert(actualCanBack === canBack, `${desc}: canGoBack should be ${canBack}, got ${actualCanBack}`);
                assert(actualCanForward === canForward, `${desc}: canGoForward should be ${canForward}, got ${actualCanForward}`);
            });
        });

        runner.test('Navigation history - branching behavior', () => {
            // Test history branching when navigating back then forward to new section
            const mockHistory = [
                { section: 'brainstorm', state: { choices: [] }, timestamp: 1000 },
                { section: 'comparison', state: { choices: ['A', 'B'] }, timestamp: 2000 },
                { section: 'scoring', state: { choices: ['A', 'B'] }, timestamp: 3000 }
            ];
            let mockIndex = 2; // Currently at scoring

            function mockGoBack() {
                if (mockIndex > 0) {
                    mockIndex--;
                    return { currentSection: mockHistory[mockIndex].section, index: mockIndex };
                }
                return null;
            }

            function mockAddEntry(section, state) {
                // Remove everything after current position (branching)
                if (mockIndex < mockHistory.length - 1) {
                    mockHistory.splice(mockIndex + 1);
                }
                
                mockHistory.push({ section, state, timestamp: Date.now() });
                mockIndex = mockHistory.length - 1;
                return { history: mockHistory, index: mockIndex };
            }

            // Go back to comparison
            const backResult = mockGoBack();
            assert(backResult.currentSection === 'comparison', 'Should navigate back to comparison');
            assert(backResult.index === 1, 'Should be at index 1');

            // Navigate to results (creating branch)
            const branchResult = mockAddEntry('results', { choices: ['A', 'B'] });
            assert(branchResult.history.length === 3, 'Should replace future history');
            assert(branchResult.history[2].section === 'results', 'Should add results section');
            assert(branchResult.index === 2, 'Should be at new end');
            
            // Verify scoring section was removed
            const hasScoring = branchResult.history.some(entry => entry.section === 'scoring');
            assert(!hasScoring, 'Should remove scoring section from history');
        });

        runner.test('Navigation history - state preservation', () => {
            // Test that navigation preserves complete state
            const mockState = {
                choices: ['Job A', 'Job B', 'Freelance'],
                selectedOptionA: 'Job A',
                selectedOptionB: 'Job B',
                formData: {
                    choiceInputs: ['Job A', 'Job B', 'Freelance'],
                    advantagesA: 'Higher salary\nGood benefits',
                    disadvantagesA: 'Long commute\nHigh stress',
                    advantagesB: 'Flexible hours\nKnown environment',
                    disadvantagesB: 'Lower pay\nLimited growth',
                    sliderValues: {
                        'slider-1-2': 65,
                        'slider-3-4': 40,
                        'slider-5-6': 75,
                        'slider-7-8': 30
                    }
                }
            };

            function mockCaptureState() {
                return JSON.parse(JSON.stringify(mockState)); // Deep copy
            }

            function mockRestoreState(state) {
                // Validate all expected properties exist
                const required = ['choices', 'selectedOptionA', 'selectedOptionB', 'formData'];
                required.forEach(prop => {
                    assert(state.hasOwnProperty(prop), `State should have ${prop} property`);
                });

                // Validate form data structure
                const formDataRequired = ['choiceInputs', 'advantagesA', 'disadvantagesA', 'advantagesB', 'disadvantagesB', 'sliderValues'];
                formDataRequired.forEach(prop => {
                    assert(state.formData.hasOwnProperty(prop), `Form data should have ${prop} property`);
                });

                // Validate data types and content
                assert(Array.isArray(state.choices), 'Choices should be array');
                assert(typeof state.selectedOptionA === 'string', 'Selected option A should be string');
                assert(Array.isArray(state.formData.choiceInputs), 'Choice inputs should be array');
                assert(typeof state.formData.advantagesA === 'string', 'Advantages A should be string');
                assert(typeof state.formData.sliderValues === 'object', 'Slider values should be object');

                return true;
            }

            const capturedState = mockCaptureState();
            const restored = mockRestoreState(capturedState);
            
            assert(restored === true, 'Should successfully restore complete state');
            assert(capturedState.choices.length === 3, 'Should preserve choices array');
            assert(capturedState.formData.advantagesA.includes('Higher salary'), 'Should preserve textarea content');
            assert(capturedState.formData.sliderValues['slider-1-2'] === 65, 'Should preserve slider values');
        });

        runner.test('Navigation history - keyboard shortcuts', () => {
            // Test keyboard shortcut logic
            function mockHandleNavigationKeydown(event, isInInput) {
                // Only handle navigation keys if user isn't typing in an input/textarea
                if (isInInput) {
                    return { handled: false, action: null };
                }

                // Alt + Left Arrow = Go Back
                if (event.altKey && event.key === 'ArrowLeft') {
                    return { handled: true, action: 'goBack' };
                }
                
                // Alt + Right Arrow = Go Forward
                if (event.altKey && event.key === 'ArrowRight') {
                    return { handled: true, action: 'goForward' };
                }

                return { handled: false, action: null };
            }

            // Test Alt+Left when not in input
            const backEvent = { altKey: true, key: 'ArrowLeft' };
            const backResult = mockHandleNavigationKeydown(backEvent, false);
            assert(backResult.handled === true, 'Should handle Alt+Left');
            assert(backResult.action === 'goBack', 'Should trigger go back');

            // Test Alt+Right when not in input
            const forwardEvent = { altKey: true, key: 'ArrowRight' };
            const forwardResult = mockHandleNavigationKeydown(forwardEvent, false);
            assert(forwardResult.handled === true, 'Should handle Alt+Right');
            assert(forwardResult.action === 'goForward', 'Should trigger go forward');

            // Test Alt+Left when in input (should be ignored)
            const inputResult = mockHandleNavigationKeydown(backEvent, true);
            assert(inputResult.handled === false, 'Should ignore when in input');
            assert(inputResult.action === null, 'Should not trigger action when in input');

            // Test other keys (should be ignored)
            const otherEvent = { altKey: true, key: 'ArrowUp' };
            const otherResult = mockHandleNavigationKeydown(otherEvent, false);
            assert(otherResult.handled === false, 'Should ignore other keys');
        });

        runner.test('Navigation history - save/load integration', () => {
            // Test that navigation history is properly saved and loaded
            const mockData = {
                choices: ['A', 'B'],
                selectedOptionA: 'A',
                selectedOptionB: 'B',
                currentSection: 'comparison',
                formData: { /* form data */ },
                navigationHistory: [
                    { section: 'brainstorm', state: { choices: [] }, timestamp: 1000 },
                    { section: 'comparison', state: { choices: ['A', 'B'] }, timestamp: 2000 }
                ],
                currentHistoryIndex: 1,
                timestamp: Date.now()
            };

            // Test saving navigation history
            function mockSaveWithHistory(data) {
                const required = ['navigationHistory', 'currentHistoryIndex'];
                required.forEach(prop => {
                    assert(data.hasOwnProperty(prop), `Save data should include ${prop}`);
                });
                
                assert(Array.isArray(data.navigationHistory), 'Navigation history should be array');
                assert(typeof data.currentHistoryIndex === 'number', 'Current history index should be number');
                
                return JSON.stringify(data);
            }

            // Test loading navigation history
            function mockLoadWithHistory(jsonData) {
                const data = JSON.parse(jsonData);
                
                if (data.navigationHistory && Array.isArray(data.navigationHistory)) {
                    const restoredHistory = [...data.navigationHistory];
                    const restoredIndex = data.currentHistoryIndex || -1;
                    
                    return {
                        history: restoredHistory,
                        index: restoredIndex,
                        valid: true
                    };
                }
                
                return { history: [], index: -1, valid: false };
            }

            const savedData = mockSaveWithHistory(mockData);
            const loadedData = mockLoadWithHistory(savedData);
            
            assert(loadedData.valid === true, 'Should successfully load navigation history');
            assert(loadedData.history.length === 2, 'Should restore correct number of history entries');
            assert(loadedData.index === 1, 'Should restore correct history index');
            assert(loadedData.history[0].section === 'brainstorm', 'Should restore first section');
            assert(loadedData.history[1].section === 'comparison', 'Should restore second section');
        });

        // Debug logging
        console.log('About to run tests...');
        console.log('Total tests registered:', runner.tests.length);
        
        // Run all tests
        try {
            runner.run();
            console.log('Tests completed successfully');
        } catch (error) {
            console.error('Error running tests:', error);
            document.getElementById('test-summary').innerHTML = 'Error running tests: ' + error.message;
            document.getElementById('test-summary').style.backgroundColor = '#e53e3e';
        }
    </script>
</body>
</html>